        -:    0:Source:E:/BubbleMAC_INFOCOM/BubbleProtocol.cpp
        -:    0:Graph:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\BubbleProtocol.cpp.gcno
        -:    0:Data:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\BubbleProtocol.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by cyx02 on 2022/6/27.
        -:    3://
        -:    4:
        -:    5:#include <cstring>
        -:    6:#include <cstdlib>
        -:    7:#include "BubbleProtocol.h"
        -:    8:#include "common.h"
        -:    9:#include "vehicle.h"
        -:   10:#include "parameters.h"
        -:   11:#include <vector>
        -:   12:#include <algorithm>
        -:   13:#include <iostream>
        -:   14:
        -:   15:using namespace std;
        -:   16:
        -:   17:#define TX_COLI 0   //同时发射
        -:   18:#define NO_COLI 1   //没有碰撞,正常解包
        -:   19:#define RX_COLI 2   //接收端碰撞
        -:   20:
        -:   21:
        -:   22:// 添加一下处理听到的一整个车队的时槽使用情况
        -:   23:// 所有车辆处理其收到的一帧之内的packets
function _Z21bubble_handle_packetsP8Duallisti called 70 returned 100% blocks executed 45%
       70:   24:void bubble_handle_packets(struct Duallist *ALL_Vehicles, int slot){
        -:   25:    struct Item * aItem, *bItem, *cItem;
        -:   26:    struct vehicle *aCar;
        -:   27:
       70:   28:    aItem = ALL_Vehicles->head;
     1002:   29:    while(aItem != NULL){
       70:   29-block  0
     1002:   29-block  1
branch  0 taken 932
branch  1 taken 70 (fallthrough)
      932:   30:        aCar = (struct vehicle*)aItem->datap;
        -:   31:
        -:   32:        //初始化记录的变量，也就是更新这些东西啦
      932:   33:        (aCar->front_Vehicles).clear();
      932:   33-block  0
call    0 returned 932
      932:   34:        (aCar->rearV_Vehicles).clear();
call    0 returned 932
      932:   35:        (aCar->queue_Vehicles).clear();
call    0 returned 932
      932:   36:        (aCar->queue_Vehicles_slot).clear();
call    0 returned 932
      932:   37:        aCar->frontV = nullptr;
      932:   38:        aCar->rearV = nullptr;
        -:   39:
   187332:   40:        for(int i = 0; i < SlotPerFrame; i++){
   187332:   40-block  0
branch  0 taken 186400
branch  1 taken 932 (fallthrough)
   186400:   41:            aCar->OHN[i] = nullptr;
   186400:   42:            aCar->THN[i] = nullptr;
   186400:   42-block  0
        -:   43:        }
        -:   44:
      932:   45:        bItem = (struct Item*)aCar->packets.head;
      936:   46:        while(bItem != NULL){
      932:   46-block  0
      936:   46-block  1
branch  0 taken 4
branch  1 taken 932 (fallthrough)
        4:   47:            struct packet* pkt = (struct packet*)bItem->datap;
        4:   48:            if(pkt->condition == TX_COLI){//这个包属于两个同时发射，无法被感知到
        4:   48-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:   49:                bItem = bItem->next;
    %%%%%:   49-block  0
        4:   50:            }else if(pkt->condition == NO_COLI){//这种属于能够正常解的包
        4:   50-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        -:   51:                //更新OHN
        4:   52:                int index = (pkt->timestamp)%SlotPerFrame;
        4:   53:                aCar->OHN[index] = pkt->srcVehicle;
        -:   54:
        -:   55:                //更新THN
      804:   56:                for(int i = 0; i < SlotPerFrame; i++){
        4:   56-block  0
      800:   56-block  1
      804:   56-block  2
branch  0 taken 800
branch  1 taken 4 (fallthrough)
      800:   57:                    if(pkt->OHN_snapshot[i]!=NULL)
      800:   57-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 800
    #####:   58:                        aCar->THN[i] = pkt->OHN_snapshot[i];
    %%%%%:   58-block  0
        -:   59:                }
        -:   60:                //更新front_Vehicles, rear_Vehicles
        4:   61:                if(strcmp(aCar->lane, pkt->srcVehicle->lane) == 0){ //处于相同车道
        4:   61-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:   62:                    if(pkt->srcVehicle->pos > aCar->pos){//同车道前方
    %%%%%:   62-block  0
branch  0 never executed
branch  1 never executed
    #####:   63:                        (aCar->front_Vehicles).push_back(pkt->srcVehicle);
    %%%%%:   63-block  0
call    0 never executed
        -:   64:                    }else{//同车道后方
    #####:   65:                        (aCar->rearV_Vehicles).push_back(pkt->srcVehicle);
    %%%%%:   65-block  0
call    0 never executed
        -:   66:                    }
        -:   67:
        -:   68:                    // 更新同车道前后最近邻车辆的信息
    #####:   69:                    aCar->forntV_his = aCar->frontV;
    #####:   70:                    aCar->rearV_his = aCar->rearV_his;
    #####:   71:                    aCar->rearV = nearestVehicle(aCar, aCar->rearV_Vehicles);
    %%%%%:   71-block  0
call    0 never executed
call    1 never executed
call    2 never executed
    #####:   72:                    aCar->frontV = nearestVehicle(aCar, aCar->rearV_Vehicles);
call    0 never executed
call    1 never executed
call    2 never executed
        -:   73:
        -:   74:                    // 更新车队信息,哪些车用了什么时槽
        -:   75://                    for(auto tmp: pkt->hashtable){
        -:   76://                        struct vehicle* bCar = tmp.first;
        -:   77://                        int slot_index = tmp.second;
        -:   78://                        aCar->queue_Vehicles[bCar] = slot_index;
        -:   79://                    }
    #####:   80:                    for(int ii = 0; ii < pkt->hashtable_slot.size(); ii++){
    %%%%%:   80-block  0
    %%%%%:   80-block  1
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   81:                        struct vehicle* bCar = pkt->hashtable_vehicles[ii];
    %%%%%:   81-block  0
call    0 never executed
    #####:   82:                        int slot_index = pkt->hashtable_slot[ii];
call    0 never executed
    #####:   83:                        aCar->queue_Vehicles.push_back(bCar);
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:   84:                        aCar->queue_Vehicles_slot.push_back(slot_index);
    %%%%%:   84-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:   85:                    }
        -:   86:
        -:   87:
        -:   88:                }else{//对于非同车道的车，若听到了一个tail，则将其车队信息更新到THN不可用中
        4:   89:                    if(pkt->srcVehicle->role_condition == ROLE_T){
        4:   89-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 4
    #####:   90:                        for(auto tmp: pkt->hashtable){
    %%%%%:   90-block  0
call    0 never executed
call    1 never executed
    %%%%%:   90-block  1
call    2 never executed
    %%%%%:   90-block  2
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####:   91:                            struct vehicle* bCar = tmp.first;
    #####:   92:                            int slot_index = tmp.second;
    #####:   93:                            aCar->THN[slot_index] = bCar;
call    0 never executed
        -:   94:                        }
        -:   95:                    }
        -:   96:                }
        4:   97:                bItem = bItem->next;
        4:   97-block  0
    #####:   98:            }else if(pkt->condition == RX_COLI){//这种属于1个接收端同时有多个包送达，不能解出包，但是能感知到包的存在
    %%%%%:   98-block  0
branch  0 never executed
branch  1 never executed
    #####:   99:                int index = (pkt->timestamp)%SlotPerFrame;
    #####:  100:                aCar->OHN[index] = pkt->srcVehicle;
    #####:  101:                bItem = bItem->next;
    %%%%%:  101-block  0
        -:  102:            }
        -:  103:        }
      932:  104:        aItem = aItem->next;
      932:  104-block  0
        -:  105:    }
        -:  106:    //cout<<"hello!!!"<<endl;
       70:  107:}
       70:  107-block  0
        -:  108:
        -:  109:// 找到一个链表（同车道）中，与aCar距离最近的车辆
function _Z14nearestVehicleP7vehicleSt6vectorIS0_SaIS0_EE called 0 returned 0% blocks executed 0%
    #####:  110:struct vehicle* nearestVehicle(struct vehicle* aCar, vector<struct vehicle*> vehicleList){
    #####:  111:    if(vehicleList.size() == 0){
    %%%%%:  111-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  112:        return nullptr;
    %%%%%:  112-block  0
        -:  113:    }
    #####:  114:    struct vehicle* ans = vehicleList[0];
    %%%%%:  114-block  0
call    0 never executed
    #####:  115:    for(int i = 0; i< vehicleList.size();i++){
    %%%%%:  115-block  0
    %%%%%:  115-block  1
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  116:        if(abs(vehicleList[i]->pos - aCar->pos) < abs(ans->pos - aCar->pos)){
    %%%%%:  116-block  0
call    0 never executed
call    1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
    #####:  117:            ans = vehicleList[i];
    %%%%%:  117-block  0
call    0 never executed
        -:  118:        }
        -:  119:    }
    #####:  120:    return ans;
    %%%%%:  120-block  0
        -:  121:}
        -:  122:
        -:  123:
function _Z10safe_rangeP7vehicleS0_ called 932 returned 100% blocks executed 75%
      932:  124:double safe_range(struct vehicle* aCar, struct vehicle* frontV){
        -:  125:    double ans;
        -:  126:
      932:  127:    if(frontV == nullptr){
      932:  127-block  0
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:  128:        return (aCar->speed)*(aCar->speed)/2/(aCar->a)+3;
      932:  128-block  0
        -:  129:    }else{
    #####:  130:        return ((aCar->speed)*(aCar->speed) - (frontV->speed)*(frontV->speed))/2/aCar->a +3;
    %%%%%:  130-block  0
        -:  131:    }
        -:  132:}
        -:  133:
        -:  134:
        -:  135://determine the communication range
function _Z25bubble_protocol_commRangeP8Duallisti called 70 returned 100% blocks executed 33%
       70:  136:void bubble_protocol_commRange(struct Duallist *ALL_Vehicles, int slot){
        -:  137:    struct Item * aItem;
        -:  138:    struct vehicle *aCar;
        -:  139:
       70:  140:    aItem = ALL_Vehicles->head;
     1002:  141:    while(aItem != NULL) {
       70:  141-block  0
     1002:  141-block  1
branch  0 taken 932
branch  1 taken 70 (fallthrough)
      932:  142:        aCar = (struct vehicle*)aItem->datap;
      932:  143:        if(aCar->frontV == nullptr && aCar->rearV == nullptr){
      932:  143-block  0
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:  143-block  1
branch  2 taken 932 (fallthrough)
branch  3 taken 0
      932:  144:            aCar->commRadius = safe_range(aCar, aCar->frontV);
      932:  144-block  0
call    0 returned 932
    #####:  145:        }else if(aCar->frontV == nullptr && aCar->rearV != nullptr){
    %%%%%:  145-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  145-block  1
branch  2 never executed
branch  3 never executed
    #####:  146:            aCar->commRadius = max(safe_range(aCar, aCar->frontV), distance_between_vehicle(aCar, aCar->rearV));
    %%%%%:  146-block  0
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  147:        }else if(aCar->frontV != nullptr && aCar->rearV == nullptr){
    %%%%%:  147-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  147-block  1
branch  2 never executed
branch  3 never executed
    #####:  148:            aCar->commRadius = max(safe_range(aCar, aCar->frontV), distance_between_vehicle(aCar, aCar->frontV));
    %%%%%:  148-block  0
call    0 never executed
call    1 never executed
call    2 never executed
        -:  149:        }else{
    #####:  150:            aCar->commRadius = max(safe_range(aCar, aCar->frontV),max(distance_between_vehicle(aCar, aCar->frontV), distance_between_vehicle(aCar, aCar->rearV)));
    %%%%%:  150-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    %%%%%:  150-block  1
call    4 never executed
call    5 never executed
call    6 never executed
        -:  151:        }
      932:  152:        aItem = aItem->next;
      932:  152-block  0
        -:  153:    }
       70:  154:}
       70:  154-block  0
        -:  155:
        -:  156:
        -:  157://determine the slot
function _Z20bubble_protocol_slotP8Duallisti called 70 returned 100% blocks executed 10%
       70:  158:void bubble_protocol_slot(struct Duallist *ALL_Vehicles, int slot){
        -:  159:    struct Item * aItem;
        -:  160:    struct vehicle *aCar;
        -:  161:
       70:  162:    aItem = ALL_Vehicles->head;
     1002:  163:    while(aItem != NULL) {
       70:  163-block  0
     1002:  163-block  1
branch  0 taken 932
branch  1 taken 70 (fallthrough)
      932:  164:        aCar = (struct vehicle*)aItem->datap;
        -:  165:
        -:  166:        //单车的case,单车的时候，随机选择
      932:  167:        if(aCar->role_condition == ROLE_S) {
      932:  167-block  0
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:  168:            slot_determine_for_access(aCar, ROLE_S);
      932:  168-block  0
call    0 returned 932
    #####:  169:        }else if(aCar->role_condition == ROLE_H){
    %%%%%:  169-block  0
branch  0 never executed
branch  1 never executed
    #####:  170:            if(aCar->slot_condition == ACCESS){
    %%%%%:  170-block  0
branch  0 never executed
branch  1 never executed
    #####:  171:                if(aCar->frontV == nullptr && aCar->rearV != nullptr && aCar->rearV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  171-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  171-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  171-block  2
branch  4 never executed
branch  5 never executed
    #####:  172:                    aCar->slot_condition = OCCUPIED;//被后车认可
    #####:  173:                    aCar->counter = 0;
    %%%%%:  173-block  0
        -:  174:                }else{
    #####:  175:                    slot_determine_for_access(aCar, ROLE_H);
    %%%%%:  175-block  0
call    0 never executed
        -:  176:                }
    #####:  177:            }else if(aCar->slot_condition == OCCUPIED){
    %%%%%:  177-block  0
branch  0 never executed
branch  1 never executed
    #####:  178:                if(aCar->frontV == nullptr && aCar->rearV != nullptr && aCar->rearV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  178-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  178-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  178-block  2
branch  4 never executed
branch  5 never executed
    #####:  179:                    aCar->slot_condition = OCCUPIED;//被后车认可
    #####:  180:                    aCar->counter = 0;
    %%%%%:  180-block  0
        -:  181:                }else{
    #####:  182:                    aCar->counter ++;
    %%%%%:  182-block  0
        -:  183:                }
    #####:  184:                if(aCar->counter == counterToChange){
    %%%%%:  184-block  0
branch  0 never executed
branch  1 never executed
    #####:  185:                    slot_determine_for_access(aCar, ROLE_H);
    %%%%%:  185-block  0
call    0 never executed
        -:  186:                }
        -:  187:            }else{
    #####:  188:                cout<<"There is an error for slot deter"<<endl;
    %%%%%:  188-block  0
call    0 never executed
call    1 never executed
        -:  189:            }
    #####:  190:        }else if(aCar->role_condition == ROLE_T){
    %%%%%:  190-block  0
branch  0 never executed
branch  1 never executed
    #####:  191:            if(aCar->role_condition == ACCESS){
    %%%%%:  191-block  0
branch  0 never executed
branch  1 never executed
    #####:  192:                if(aCar->rearV == nullptr && aCar->frontV != nullptr && aCar->frontV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  192-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  192-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  192-block  2
branch  4 never executed
branch  5 never executed
    #####:  193:                    aCar->slot_condition = OCCUPIED;//被后车认可
    #####:  194:                    aCar->counter = 0;
    %%%%%:  194-block  0
        -:  195:                }else{
    #####:  196:                    slot_determine_for_access(aCar, ROLE_H);
    %%%%%:  196-block  0
call    0 never executed
        -:  197:                }
    #####:  198:            }else if(aCar->slot_condition == OCCUPIED){
    %%%%%:  198-block  0
branch  0 never executed
branch  1 never executed
    #####:  199:                if(aCar->rearV == nullptr && aCar->frontV != nullptr && aCar->frontV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  199-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  199-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  199-block  2
branch  4 never executed
branch  5 never executed
    #####:  200:                    aCar->slot_condition = OCCUPIED;//被后车认可
    #####:  201:                    aCar->counter = 0;
    %%%%%:  201-block  0
        -:  202:                }else{
    #####:  203:                    aCar->counter++;
    %%%%%:  203-block  0
        -:  204:                }
        -:  205:
    #####:  206:                if(aCar->counter == counterToChange){
    %%%%%:  206-block  0
branch  0 never executed
branch  1 never executed
    #####:  207:                    slot_determine_for_access(aCar, ROLE_H);
    %%%%%:  207-block  0
call    0 never executed
        -:  208:                }
        -:  209:            }
    #####:  210:        }else if(aCar->role_condition == ROLE_I){
    %%%%%:  210-block  0
branch  0 never executed
branch  1 never executed
    #####:  211:            if(aCar->role_condition == ACCESS){
    %%%%%:  211-block  0
branch  0 never executed
branch  1 never executed
    #####:  212:                if(aCar->rearV != nullptr && aCar->frontV != nullptr && aCar->frontV->OHN[aCar->slot_occupied] == aCar && aCar->rearV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  212-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  212-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  212-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  212-block  3
branch  6 never executed
branch  7 never executed
    #####:  213:                    aCar->slot_condition = OCCUPIED;//被后车认可
    #####:  214:                    aCar->counter = 0;
    %%%%%:  214-block  0
        -:  215:                }else{
    #####:  216:                    slot_determine_for_access(aCar, ROLE_I);
    %%%%%:  216-block  0
call    0 never executed
        -:  217:                }
    #####:  218:            }else if(aCar->role_condition == OCCUPIED){
    %%%%%:  218-block  0
branch  0 never executed
branch  1 never executed
    #####:  219:                if(aCar->rearV != nullptr && aCar->frontV != nullptr && aCar->frontV->OHN[aCar->slot_occupied] == aCar && aCar->rearV->OHN[aCar->slot_occupied] == aCar){
    %%%%%:  219-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  219-block  1
branch  2 never executed
branch  3 never executed
    %%%%%:  219-block  2
branch  4 never executed
branch  5 never executed
    %%%%%:  219-block  3
branch  6 never executed
branch  7 never executed
    #####:  220:                    aCar->slot_condition = OCCUPIED;//被前后车认可
    #####:  221:                    aCar->counter = 0;
    %%%%%:  221-block  0
        -:  222:                }else{
    #####:  223:                    aCar->counter++;
    %%%%%:  223-block  0
        -:  224:                }
    #####:  225:                if(aCar->counter == counterToChange){
    %%%%%:  225-block  0
branch  0 never executed
branch  1 never executed
    #####:  226:                    slot_determine_for_access(aCar, ROLE_H);
    %%%%%:  226-block  0
call    0 never executed
        -:  227:                }
        -:  228:            }
        -:  229:        }
      932:  230:        aItem = aItem->next;
      932:  230-block  0
        -:  231:    }
       70:  232:}
        -:  233:
        -:  234:
function _Z25slot_determine_for_accessP7vehiclei called 932 returned 100% blocks executed 24%
      932:  235:void slot_determine_for_access(struct vehicle* aCar, int role){
        -:  236:
      932:  237:    if(aCar->frontV == nullptr && aCar->rearV == nullptr){
      932:  237-block  0
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:  237-block  1
branch  2 taken 932 (fallthrough)
branch  3 taken 0
      932:  238:        aCar->role_condition = ROLE_S;
      932:  239:        aCar->slot_occupied = choose_slot(aCar, ROLE_S);
      932:  239-block  0
call    0 returned 932
      932:  240:        aCar->slot_condition = ACCESS;
    #####:  241:    }else if(aCar->frontV == nullptr && aCar->rearV != nullptr){
    %%%%%:  241-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  241-block  1
branch  2 never executed
branch  3 never executed
    #####:  242:        aCar->role_condition = ROLE_H;
    #####:  243:        aCar->slot_occupied = choose_slot(aCar, ROLE_H);
    %%%%%:  243-block  0
call    0 never executed
    #####:  244:        aCar->slot_condition = ACCESS;
    #####:  245:    }else if(aCar->frontV != nullptr && aCar->rearV == nullptr){
    %%%%%:  245-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  245-block  1
branch  2 never executed
branch  3 never executed
    #####:  246:        aCar->role_condition = ROLE_T;
    #####:  247:        aCar->slot_occupied = choose_slot(aCar, ROLE_T);
    %%%%%:  247-block  0
call    0 never executed
    #####:  248:        aCar->slot_condition = ACCESS;
    #####:  249:    }else if(aCar->frontV != nullptr && aCar->rearV != nullptr){
    %%%%%:  249-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  249-block  1
branch  2 never executed
branch  3 never executed
    #####:  250:        aCar->role_condition = ROLE_I;
    #####:  251:        aCar->slot_occupied = choose_slot(aCar, ROLE_I);
    %%%%%:  251-block  0
call    0 never executed
    #####:  252:        aCar->slot_condition = ACCESS;
        -:  253:    }else{
    #####:  254:        cout<<"ERROR to determine a slot for "<< role <<" vehicle"<<endl;
    %%%%%:  254-block  0
call    0 never executed
call    1 never executed
call    2 never executed
call    3 never executed
        -:  255:    }
      932:  256:}
        -:  257:
        -:  258://根据角色，在对应的时槽资源块内随机进行时槽选择；拒绝采样
function _Z11choose_slotP7vehiclei called 932 returned 100% blocks executed 29%
      932:  259:int choose_slot(struct vehicle* aCar, int role){
        -:  260:    int a, b;
      932:  261:    int ans = 0;
        -:  262:
      932:  263:        switch(role) {
      932:  263-block  0
branch  0 taken 0
branch  1 taken 932
branch  2 taken 0
branch  3 taken 0
branch  4 taken 0
branch  5 taken 0
    #####:  264:            case ROLE_H:
    #####:  265:                a = 0;
    #####:  266:                b = len_head_resource -1;
    %%%%%:  266-block  0
        -:  267:                while(1){
    #####:  268:                    ans = rand()%(b - a + 1) + a;
    %%%%%:  268-block  0
call    0 never executed
    #####:  269:                    if(aCar->THN[ans]== NULL) break;
branch  0 never executed
branch  1 never executed
    %%%%%:  269-block  0
        -:  270:                }
    #####:  271:                break;
    %%%%%:  271-block  0
      932:  272:            case ROLE_S:
      932:  273:                a = len_head_resource;
      932:  274:                b = (SlotPerFrame - 1)/2 - len_tail_resouce ;
      932:  274-block  0
        -:  275:                while(1){
      932:  276:                    ans = rand()%(b - a + 1) + a;
      932:  276-block  0
call    0 returned 932
      932:  277:                    if(aCar->THN[ans]== NULL) break;
branch  0 taken 932 (fallthrough)
branch  1 taken 0
      932:  277-block  0
        -:  278:                }
      932:  279:                break;
      932:  279-block  0
    #####:  280:            case ROLE_I:
    #####:  281:                a = len_head_resource;
    #####:  282:                b = (SlotPerFrame - 1)/2 - len_tail_resouce ;
    %%%%%:  282-block  0
        -:  283:                while(1){
    #####:  284:                    ans = rand()%(b - a + 1) + a;
    %%%%%:  284-block  0
call    0 never executed
    #####:  285:                    if(aCar->THN[ans]== NULL) break;
branch  0 never executed
branch  1 never executed
    %%%%%:  285-block  0
        -:  286:                }
    #####:  287:                break;
    %%%%%:  287-block  0
    #####:  288:            case ROLE_T:
    #####:  289:                a = (SlotPerFrame - 1)/2 - len_tail_resouce;
    #####:  290:                b = (SlotPerFrame - 1)/2 ;
    %%%%%:  290-block  0
        -:  291:                while(1){
    #####:  292:                    ans = rand()%(b - a + 1) + a;
    %%%%%:  292-block  0
call    0 never executed
    #####:  293:                    if(aCar->THN[ans]== NULL) break;
branch  0 never executed
branch  1 never executed
    %%%%%:  293-block  0
        -:  294:                }
    #####:  295:                break;
    %%%%%:  295-block  0
    #####:  296:            case ROLE_VeMAC:
    #####:  297:                a = 0;
    #####:  298:                b = (SlotPerFrame - 1)/2;
    %%%%%:  298-block  0
        -:  299:                while(1){
    #####:  300:                    ans = rand()%(b - a + 1) + a;
    %%%%%:  300-block  0
call    0 never executed
    #####:  301:                    if(aCar->THN[ans]== NULL) break;
branch  0 never executed
branch  1 never executed
    %%%%%:  301-block  0
        -:  302:                }
    #####:  303:                break;
    %%%%%:  303-block  0
        -:  304:        }
      932:  305:        if(aCar->resource_pool == 0)
      932:  305-block  0
branch  0 taken 481 (fallthrough)
branch  1 taken 451
      481:  306:            return ans;
      481:  306-block  0
        -:  307:        else
      451:  308:            return ans + (SlotPerFrame - 1) / 2;
      451:  308-block  0
        -:  309:}
