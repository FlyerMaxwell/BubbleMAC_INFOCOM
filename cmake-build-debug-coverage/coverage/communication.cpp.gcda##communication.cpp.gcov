        -:    0:Source:E:/BubbleMAC_INFOCOM/communication.cpp
        -:    0:Graph:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\communication.cpp.gcno
        -:    0:Data:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\communication.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by cyx02 on 2022/6/27.
        -:    3://
        -:    4:
        -:    5:#include "communication.h"
        -:    6:#include "stddef.h"
        -:    7:#include "vehicle.h"
        -:    8:#include "parameters.h"
        -:    9:#include "packets.h"
        -:   10:#include "collision.h"
        -:   11:#include <iostream>
        -:   12:using namespace std;
        -:   13:
        -:   14:
        -:   15:// transmit packets. For each vehicle, if it is a tx, it broadcast to neighbors within its communication range. If the rx also is a tx, there will be a collision, if not  it will receive the packet.
function _Z18handle_transmitterP8Duallisti called 14000 returned 100% blocks executed 100%
    14000:   16:void handle_transmitter(struct Duallist *ALL_Vehicles, int slot){
        -:   17:    struct Item *aItem, *bItem;
        -:   18:    struct vehicle *aCar, *bCar;
        -:   19:
    14000:   20:    aItem = ALL_Vehicles->head;
   197985:   21:    while(aItem != NULL){
    14000:   21-block  0
   197985:   21-block  1
branch  0 taken 183985
branch  1 taken 14000 (fallthrough)
   183985:   22:        aCar = (struct vehicle*)aItem->datap;
        -:   23:
        -:   24:        //若车辆占用时槽并非当前时槽，则跳过(略过所有的receiver)
   183985:   25:        if(aCar->slot_occupied != slot % SlotPerFrame){
   183985:   25-block  0
branch  0 taken 183686 (fallthrough)
branch  1 taken 299
   183686:   26:            aItem = aItem->next;
   183686:   27:            continue;
   183686:   27-block  0
        -:   28:        }
        -:   29:
        -:   30:       // cout<<"Current Slot:"<<slot<<"Current Transmitter: "<<aCar->id<<endl;//对当前时槽正好发射的节点进行操作
      299:   31:        cnt_pkt_tx++;
      299:   32:        bItem = (struct Item*)aCar->neighbours.head;//遍历当前transmitter的邻居节点
     7686:   33:        while(bItem != NULL){
      299:   33-block  0
     7686:   33-block  1
branch  0 taken 7387
branch  1 taken 299 (fallthrough)
     7387:   34:            bCar = (struct vehicle*)bItem->datap;
        -:   35:            //printf("bCar Id: %s\n", bCar->id);
     7387:   36:            double distanceAB = distance_between_vehicle(aCar, bCar);
     7387:   36-block  0
call    0 returned 7387
     7387:   37:            if(aCar->commRadius < distanceAB){
branch  0 taken 6338 (fallthrough)
branch  1 taken 1049
        -:   38:                //printf("%d 's Comm Range is: %lf, OutRange neighbor is %d, distance is %lf\n",aCar->id,  aCar->commRadius, bCar->id,distanceAB);
     6338:   39:                bItem = bItem->next;
     6338:   39-block  0
        -:   40:            }else{
        -:   41:                //printf("%d 's Comm Range is: %lf, InRange neighbor is %d, distance is %lf\n", aCar->id,aCar->commRadius, bCar->id, distanceAB);
     1049:   42:                if(bCar->slot_occupied == aCar->slot_occupied){     //若此时目标车辆也在发送，则产生collision
     1049:   42-block  0
branch  0 taken 13 (fallthrough)
branch  1 taken 1036
       13:   43:                    cnt_pkt_0++;
       13:   44:                    struct packet* pkt = generate_packet(aCar,bCar,slot,0);
       13:   44-block  0
call    0 returned 13
       13:   45:                    duallist_add_to_head(&(bCar->packets), pkt);
call    0 returned 13
        -:   46:                    //printf("A packet! cnt_pkt: %d, src: %s, dst:%s ,slot:%d, condition:%d \n", cnt_pkt, aCar->id, bCar->id,slot,pkt->condition);
        -:   47:                    // log_packet(pkt,slot);
        -:   48:
       13:   49:                    struct collision* coli =  generate_collision(aCar,bCar,0,slot);
call    0 returned 13
        -:   50:                    //log_collision(coli);
       13:   51:                    bItem = bItem->next;
        -:   52:                }else{
     1036:   53:                    struct packet* pkt = generate_packet(aCar,bCar,slot,1);
     1036:   53-block  0
call    0 returned 1036
     1036:   54:                    duallist_add_to_head(&(bCar->packets), pkt);
call    0 returned 1036
        -:   55:                    //printf("A packet! cnt_pkt: %d, src: %s, dst:%s ,slot:%d, condition:%d \n", cnt_pkt, aCar->id, bCar->id,slot,pkt->condition);
        -:   56:                    //log_packet(pkt,slot);
     1036:   57:                    bItem = bItem->next;
        -:   58:                }
        -:   59:            }
        -:   60:        }
      299:   61:        aItem =aItem->next;
      299:   61-block  0
        -:   62:    }
    14000:   63:}
        -:   64:
        -:   65:
function _Z15handle_receiverP8Duallisti called 14000 returned 100% blocks executed 85%
    14000:   66:void handle_receiver(struct Duallist *ALL_Vehicles, int slot){
        -:   67:    struct Item *aItem, *bItem;
        -:   68:    struct vehicle *aCar;
        -:   69:
    14000:   70:    aItem = ALL_Vehicles->head;
   197985:   71:    while(aItem != NULL){
    14000:   71-block  0
   197985:   71-block  1
branch  0 taken 183985
branch  1 taken 14000 (fallthrough)
   183985:   72:        aCar = (struct vehicle*)aItem->datap;
        -:   73:
   183985:   74:        if(aCar->slot_occupied == slot%SlotPerFrame) {
   183985:   74-block  0
branch  0 taken 299 (fallthrough)
branch  1 taken 183686
      299:   75:            aItem = aItem->next;
        -:   76:            // printf("There is a transmitter!\n");
      299:   77:            continue; //忽略掉transmitter
      299:   77-block  0
        -:   78:        }
        -:   79:
        -:   80:        //printf("Current Slot: %d, Current Receiver: %d\n", slot, aCar->id);//对当前时槽正好发射的节点进行操作
        -:   81:        //到目前时间一直都没有收到包
   183686:   82:        if(aCar->packets.nItems == 0){
   183686:   82-block  0
branch  0 taken 151797 (fallthrough)
branch  1 taken 31889
   151797:   83:            aItem = aItem->next;
        -:   84:            // printf("There is no packets!\n");
   151797:   85:            continue;
   151797:   85-block  0
        -:   86:        }
        -:   87:
        -:   88:        //数一下当前slot收到了多少个包---->packet只有当一个完整的frame才刷新
    31889:   89:        int cnt_cur_pkt = 0;
    31889:   90:        bItem =  (struct Item*)aCar->packets.head;
    32925:   91:        while(bItem != NULL){
    31889:   91-block  0
    32925:   91-block  1
branch  0 taken 32385
branch  1 taken 540 (fallthrough)
    32385:   92:            struct packet* pkt= (struct packet*)bItem->datap;
        -:   93:
    32385:   94:            if(pkt->timestamp != slot)//仅统计当前slot的pkt
    32385:   94-block  0
branch  0 taken 31349 (fallthrough)
branch  1 taken 1036
    31349:   95:                break;
    31349:   95-block  0
        -:   96:            else
     1036:   97:                cnt_cur_pkt++;
        -:   98:
     1036:   99:            bItem = bItem->next;
     1036:   99-block  0
        -:  100:        }
        -:  101:
        -:  102:
    31889:  103:        if(cnt_cur_pkt == 1){
    31889:  103-block  0
branch  0 taken 990 (fallthrough)
branch  1 taken 30899
      990:  104:            bItem = (struct Item*)aCar->packets.head;
      990:  105:            struct packet* pkt= (struct packet*)bItem->datap;
      990:  106:            pkt->condition = 1;
        -:  107:            // log_packet(pkt,slot);       //正常收包
      990:  108:            cnt_pkt_1++;
      990:  109:            cnt_received++;
      990:  109-block  0
    30899:  110:        }else if(cnt_cur_pkt >=2 ){     //产生碰撞的包
    30899:  110-block  0
branch  0 taken 23 (fallthrough)
branch  1 taken 30876
       23:  111:            cnt_pkt_2 += cnt_cur_pkt;
       23:  112:            bItem = (struct Item*)aCar->packets.head;
       91:  113:            while(bItem!=NULL){
       23:  113-block  0
       91:  113-block  1
branch  0 taken 68
branch  1 taken 23 (fallthrough)
       68:  114:                struct packet* pkt= (struct packet*)bItem->datap;
       68:  115:                pkt->condition = 2;
        -:  116:                // log_packet(pkt,slot);
       68:  117:                if(pkt->timestamp == slot){
       68:  117-block  0
branch  0 taken 46 (fallthrough)
branch  1 taken 22
       46:  118:                    if(pkt->srcVehicle->slot_condition == 1){
       46:  118-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 46
        -:  119:                        //printf("hello!!!!_____________________________________________!!!!!!\n");
        -:  120:                        //printf("%d %d\n",aCar->id,pkt->srcVehicle->id);
    #####:  121:                        struct collision* coli = generate_collision(aCar,pkt->srcVehicle,1,slot);
    %%%%%:  121-block  0
call    0 never executed
        -:  122:                        // log_collision(coli);
       46:  123:                    }else if(pkt->srcVehicle->slot_condition == 2){
       46:  123-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 46
        -:  124:                        //printf("hello!!!!_____________________________________________~~~~~~~\n");
    #####:  125:                        struct collision* coli = generate_collision(aCar,pkt->srcVehicle,2,slot);
    %%%%%:  125-block  0
call    0 never executed
        -:  126:                        // log_collision(coli);
        -:  127:                    }
        -:  128:                   // printf("hello!!!!_____________________________________________\n");
        -:  129:                }
       68:  130:                bItem = bItem->next;
       68:  130-block  0
        -:  131:            }
        -:  132:        }
        -:  133:        //printf("hello\n");
    31889:  134:        aItem = aItem->next;
    31889:  134-block  0
        -:  135:    }
    14000:  136:}
