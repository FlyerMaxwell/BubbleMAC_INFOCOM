        -:    0:Source:E:/BubbleMAC_INFOCOM/communication.cpp
        -:    0:Graph:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\communication.cpp.gcno
        -:    0:Data:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\communication.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by cyx02 on 2022/6/27.
        -:    3://
        -:    4:
        -:    5:#include "communication.h"
        -:    6:#include "stddef.h"
        -:    7:#include "vehicle.h"
        -:    8:#include "parameters.h"
        -:    9:#include "packets.h"
        -:   10:#include "collision.h"
        -:   11:
        -:   12:
        -:   13:// transmit packets. For each vehicle, if it is a tx, it broadcast to neighbors within its communication range. If the rx also is a tx, there will be a collision, if not  it will receive the packet.
function _Z18handle_transmitterP8Duallisti called 400 returned 100% blocks executed 71%
      400:   14:void handle_transmitter(struct Duallist *ALL_Vehicles, int slot){
        -:   15:    struct Item *aItem, *bItem;
        -:   16:    struct vehicle *aCar, *bCar;
        -:   17:
      400:   18:    aItem = ALL_Vehicles->head;
     9145:   19:    while(aItem != NULL){
      400:   19-block  0
     9145:   19-block  1
branch  0 taken 8745
branch  1 taken 400 (fallthrough)
     8745:   20:        aCar = (struct vehicle*)aItem->datap;
        -:   21:
        -:   22:        //若车辆占用时槽并非当前时槽，则跳过(略过所有的receiver)
     8745:   23:        if(aCar->slot_occupied != slot % SlotPerFrame){
     8745:   23-block  0
branch  0 taken 8734 (fallthrough)
branch  1 taken 11
     8734:   24:            aItem = aItem->next;
     8734:   25:            continue;
     8734:   25-block  0
        -:   26:        }
        -:   27:
       11:   28:        printf("Current Slot: %d, Current Transmitter: %s\n", slot, aCar->id);//对当前时槽正好发射的节点进行操作
       11:   28-block  0
call    0 returned 11
       11:   29:        cnt_pkt_tx++;
       11:   30:        bItem = (struct Item*)aCar->neighbours.head;//遍历当前transmitter的邻居节点
      236:   31:        while(bItem != NULL){
      236:   31-block  0
branch  0 taken 225
branch  1 taken 11 (fallthrough)
      225:   32:            bCar = (struct vehicle*)bItem->datap;
        -:   33:            //printf("bCar Id: %s\n", bCar->id);
      225:   34:            double distanceAB = distance_between_vehicle(aCar, bCar);
      225:   34-block  0
call    0 returned 225
      225:   35:            if(aCar->commRadius < distanceAB){
branch  0 taken 180 (fallthrough)
branch  1 taken 45
        -:   36:                //printf("%d 's Comm Range is: %lf, OutRange neighbor is %d, distance is %lf\n",aCar->id,  aCar->commRadius, bCar->id,distanceAB);
      180:   37:                bItem = bItem->next;
      180:   37-block  0
        -:   38:            }else{
        -:   39:                //printf("%d 's Comm Range is: %lf, InRange neighbor is %d, distance is %lf\n", aCar->id,aCar->commRadius, bCar->id, distanceAB);
       45:   40:                if(bCar->slot_occupied == aCar->slot_occupied){     //若此时目标车辆也在发送，则产生collision
       45:   40-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 45
    #####:   41:                    cnt_pkt_0++;
    #####:   42:                    struct packet* pkt = generate_packet(aCar,bCar,slot,0);
    %%%%%:   42-block  0
call    0 never executed
    #####:   43:                    duallist_add_to_head(&(bCar->packets), pkt);
call    0 never executed
    #####:   44:                    printf("A packet! cnt_pkt: %d, src: %s, dst:%s ,slot:%d, condition:%d \n", cnt_pkt, aCar->id, bCar->id,slot,pkt->condition);
call    0 never executed
    #####:   45:                    log_packet(pkt,slot);
call    0 never executed
        -:   46:
    #####:   47:                    struct collision* coli =  generate_collision(aCar,bCar,0,slot);
call    0 never executed
    #####:   48:                    log_collision(coli);
call    0 never executed
    #####:   49:                    bItem = bItem->next;
        -:   50:                }else{
       45:   51:                    struct packet* pkt = generate_packet(aCar,bCar,slot,1);
       45:   51-block  0
call    0 returned 45
       45:   52:                    duallist_add_to_head(&(bCar->packets), pkt);
call    0 returned 45
       45:   53:                    printf("A packet! cnt_pkt: %d, src: %s, dst:%s ,slot:%d, condition:%d \n", cnt_pkt, aCar->id, bCar->id,slot,pkt->condition);
call    0 returned 45
        -:   54:                    //log_packet(pkt,slot);
       45:   55:                    bItem = bItem->next;
        -:   56:                }
        -:   57:            }
        -:   58:        }
       11:   59:        aItem =aItem->next;
       11:   59-block  0
        -:   60:    }
      400:   61:}
        -:   62:
        -:   63:
function _Z15handle_receiverP8Duallisti called 400 returned 100% blocks executed 59%
      400:   64:void handle_receiver(struct Duallist *ALL_Vehicles, int slot){
        -:   65:    struct Item *aItem, *bItem;
        -:   66:    struct vehicle *aCar;
        -:   67:
      400:   68:    aItem = ALL_Vehicles->head;
     9145:   69:    while(aItem != NULL){
      400:   69-block  0
     9145:   69-block  1
branch  0 taken 8745
branch  1 taken 400 (fallthrough)
     8745:   70:        aCar = (struct vehicle*)aItem->datap;
        -:   71:
     8745:   72:        if(aCar->slot_occupied == slot%SlotPerFrame) {
     8745:   72-block  0
branch  0 taken 11 (fallthrough)
branch  1 taken 8734
       11:   73:            aItem = aItem->next;
        -:   74:            // printf("There is a transmitter!\n");
       11:   75:            continue; //忽略掉transmitter
       11:   75-block  0
        -:   76:        }
        -:   77:
        -:   78:        //printf("Current Slot: %d, Current Receiver: %d\n", slot, aCar->id);//对当前时槽正好发射的节点进行操作
        -:   79:        //到目前时间一直都没有收到包
     8734:   80:        if(aCar->packets.nItems == 0){
     8734:   80-block  0
branch  0 taken 7619 (fallthrough)
branch  1 taken 1115
     7619:   81:            aItem = aItem->next;
        -:   82:            // printf("There is no packets!\n");
     7619:   83:            continue;
     7619:   83-block  0
        -:   84:        }
        -:   85:
        -:   86:        //数一下当前slot收到了多少个包---->packet只有当一个完整的frame才刷新
     1115:   87:        int cnt_cur_pkt = 0;
     1115:   88:        bItem =  (struct Item*)aCar->packets.head;
     1160:   89:        while(bItem != NULL){
     1115:   89-block  0
     1160:   89-block  1
branch  0 taken 1142
branch  1 taken 18 (fallthrough)
     1142:   90:            struct packet* pkt= (struct packet*)bItem->datap;
        -:   91:
     1142:   92:            if(pkt->timestamp != slot)//仅统计当前slot的pkt
     1142:   92-block  0
branch  0 taken 1097 (fallthrough)
branch  1 taken 45
     1097:   93:                break;
     1097:   93-block  0
        -:   94:            else
       45:   95:                cnt_cur_pkt++;
        -:   96:
       45:   97:            bItem = bItem->next;
       45:   97-block  0
        -:   98:        }
        -:   99:
        -:  100:
     1115:  101:        if(cnt_cur_pkt == 1){
     1115:  101-block  0
branch  0 taken 45 (fallthrough)
branch  1 taken 1070
       45:  102:            bItem = (struct Item*)aCar->packets.head;
       45:  103:            struct packet* pkt= (struct packet*)bItem->datap;
       45:  104:            pkt->condition = 1;
        -:  105:            // log_packet(pkt,slot);       //正常收包
       45:  106:            cnt_pkt_1++;
       45:  107:            cnt_received++;
       45:  107-block  0
     1070:  108:        }else if(cnt_cur_pkt >=2 ){     //产生碰撞的包
     1070:  108-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1070
    #####:  109:            cnt_pkt_2 += cnt_cur_pkt;
    #####:  110:            bItem = (struct Item*)aCar->packets.head;
    #####:  111:            while(bItem!=NULL){
    %%%%%:  111-block  0
    %%%%%:  111-block  1
branch  0 never executed
branch  1 never executed
    #####:  112:                struct packet* pkt= (struct packet*)bItem->datap;
    #####:  113:                pkt->condition = 2;
        -:  114:                // log_packet(pkt,slot);
    #####:  115:                if(pkt->timestamp == slot){
    %%%%%:  115-block  0
branch  0 never executed
branch  1 never executed
    #####:  116:                    if(pkt->srcVehicle->slot_condition == 1){
    %%%%%:  116-block  0
branch  0 never executed
branch  1 never executed
        -:  117:                        //printf("hello!!!!_____________________________________________!!!!!!\n");
        -:  118:                        //printf("%d %d\n",aCar->id,pkt->srcVehicle->id);
    #####:  119:                        struct collision* coli = generate_collision(aCar,pkt->srcVehicle,1,slot);
    %%%%%:  119-block  0
call    0 never executed
        -:  120:                        // log_collision(coli);
    #####:  121:                    }else if(pkt->srcVehicle->slot_condition == 2){
    %%%%%:  121-block  0
branch  0 never executed
branch  1 never executed
        -:  122:                        //printf("hello!!!!_____________________________________________~~~~~~~\n");
    #####:  123:                        struct collision* coli = generate_collision(aCar,pkt->srcVehicle,2,slot);
    %%%%%:  123-block  0
call    0 never executed
        -:  124:                        // log_collision(coli);
        -:  125:                    }
    #####:  126:                    printf("hello!!!!_____________________________________________\n");
    %%%%%:  126-block  0
call    0 never executed
        -:  127:                }
    #####:  128:                bItem = bItem->next;
    %%%%%:  128-block  0
        -:  129:            }
        -:  130:        }
        -:  131:        //printf("hello\n");
     1115:  132:        aItem = aItem->next;
     1115:  132-block  0
        -:  133:    }
      400:  134:}
