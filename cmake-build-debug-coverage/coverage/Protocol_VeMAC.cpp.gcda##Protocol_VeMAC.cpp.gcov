        -:    0:Source:E:/BubbleMAC_INFOCOM/Protocol_VeMAC.cpp
        -:    0:Graph:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\Protocol_VeMAC.cpp.gcno
        -:    0:Data:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\Protocol_VeMAC.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by cyx02 on 2022/7/5.
        -:    3://
        -:    4:
        -:    5:#include "Protocol_VeMAC.h"
        -:    6:#include "parameters.h"
        -:    7:#include <cstdlib>
        -:    8:#include "vehicle.h"
        -:    9:#include "BubbleProtocol.h"
        -:   10:
        -:   11:
        -:   12:/*
        -:   13:VeMAC
        -:   14:协议过程：
        -:   15:1. 每个车监听一帧，更新OHN和THN的时槽使用情况
        -:   16:2. 根据状态进行时槽选择
        -:   17:    1）若ve_slot_condition == 0, 车辆未进行时槽选择，则其随机选择一个没有占用的slot，并设置slot_condition = 1
        -:   18:    2）若ve_slot_condition == 1, 车辆进行时槽请求，此时判断所有收到的packets中，OHN是否都认可了自己，如果认可了自己，则仍选择ve_slot_occupied，并将ve_slot_condition=2；若并未都认可自己，则继续随机选择时槽
        -:   19:    3）若ve_slot_condition == 2，车辆已选择固定时槽，此时判断所有收到的packets中，OHN是否都认可了自己，如果认可了自己，保持；如果并非都认可了自己，则ve_count_srp--;若ve_count_srp==0,则重新回到2）
        -:   20:3. 选择完后重置OHN和THN为NULL
        -:   21:*/
function _Z6ve_macP8Duallisti called 0 returned 0% blocks executed 0%
    #####:   22:void ve_mac(struct Duallist *ALL_Vehicles, int slot){
        -:   23:
        -:   24:    struct Item *aItem, *bItem;
        -:   25:    struct vehicle* aCar;
        -:   26:
        -:   27:    //step1: update OHN and THN
    #####:   28:    aItem = ALL_Vehicles->head;
    #####:   29:    while(aItem != NULL){
    %%%%%:   29-block  0
    %%%%%:   29-block  1
branch  0 never executed
branch  1 never executed
    #####:   30:        aCar = (struct vehicle*)aItem->datap;               //[a,b] (rand()%(b-a+1))+a
    #####:   31:        aCar->ve_check_flag = 1;//是否被周围邻居都认可
        -:   32:
    #####:   33:        struct Item* bItem =(struct Item *) aCar->packets.head;
    #####:   34:        while(bItem != NULL){
    %%%%%:   34-block  0
    %%%%%:   34-block  1
branch  0 never executed
branch  1 never executed
    #####:   35:            struct packet* pkt = (struct packet*) bItem->datap;
    #####:   36:            if(pkt->condition == 0){         //condition为0的包车辆是听不到的，也解不出
    %%%%%:   36-block  0
branch  0 never executed
branch  1 never executed
    #####:   37:                bItem = bItem->next;
    %%%%%:   37-block  0
    #####:   38:            }else if(pkt->condition == 1){
    %%%%%:   38-block  0
branch  0 never executed
branch  1 never executed
    #####:   39:                int index = (pkt->timestamp)%SlotPerFrame;
    #####:   40:                aCar->OHN[index] = pkt->srcVehicle;
        -:   41:
        -:   42:                //对于能解出来的包，按照其OHN_snapshot更新自己的THN
    #####:   43:                for(int i = 0; i < SlotPerFrame; i++){
    %%%%%:   43-block  0
    %%%%%:   43-block  1
    %%%%%:   43-block  2
branch  0 never executed
branch  1 never executed
    #####:   44:                    if(pkt->OHN_snapshot[i]!=NULL)
    %%%%%:   44-block  0
branch  0 never executed
branch  1 never executed
    #####:   45:                        aCar->THN[i] = pkt->OHN_snapshot[i];
    %%%%%:   45-block  0
        -:   46:                }
        -:   47:                //检测是否全部认可了自己
    #####:   48:                if(pkt->OHN_snapshot[aCar->slot_occupied] != aCar)
    %%%%%:   48-block  0
branch  0 never executed
branch  1 never executed
    #####:   49:                    aCar->ve_check_flag = 0;
    %%%%%:   49-block  0
        -:   50:
    #####:   51:                bItem = bItem->next;
    %%%%%:   51-block  0
    #####:   52:            }else if(pkt->condition == 2){//对于冲突的包，只需要更新OHN为占用即可
    %%%%%:   52-block  0
branch  0 never executed
branch  1 never executed
    #####:   53:                int index = (pkt->timestamp)%SlotPerFrame;
    #####:   54:                aCar->OHN[index] = pkt->srcVehicle;
    #####:   55:                bItem = bItem->next;
    %%%%%:   55-block  0
        -:   56:            }
        -:   57:        }
    #####:   58:        aItem = aItem->next;
    %%%%%:   58-block  0
        -:   59:    }
        -:   60:    //printf("sadasdasdsadasdas\n");
        -:   61:
        -:   62:    //step2: choose slot according to ve_slot_condition
    #####:   63:    aItem = ALL_Vehicles-> head;
    #####:   64:    while(aItem != NULL){
    %%%%%:   64-block  0
    %%%%%:   64-block  1
branch  0 never executed
branch  1 never executed
    #####:   65:        aCar = (struct vehicle*)aItem->datap;
    #####:   66:        aCar->commRadius = 300;
        -:   67:
    #####:   68:        if(aCar->slot_condition == 0){
    %%%%%:   68-block  0
branch  0 never executed
branch  1 never executed
    #####:   69:            aCar->slot_occupied = choose_slot(aCar,ROLE_VeMAC);
    %%%%%:   69-block  0
call    0 never executed
    #####:   70:            aCar->slot_condition = 1;
    #####:   71:        }else if(aCar->slot_condition == 1){
    %%%%%:   71-block  0
branch  0 never executed
branch  1 never executed
    #####:   72:            if(aCar->ve_check_flag == 1){//若被认可
    %%%%%:   72-block  0
branch  0 never executed
branch  1 never executed
    #####:   73:                aCar->slot_condition = 2;
    #####:   74:                aCar->ve_count_srp = 3;
    %%%%%:   74-block  0
        -:   75:            }else{//若不被认可
    #####:   76:                aCar->slot_occupied = choose_slot(aCar, ROLE_VeMAC);
    %%%%%:   76-block  0
call    0 never executed
    #####:   77:                aCar->slot_condition = 1;
        -:   78:            }
    #####:   79:        }else if(aCar->slot_condition == 2){
    %%%%%:   79-block  0
branch  0 never executed
branch  1 never executed
    #####:   80:            if(aCar->ve_check_flag == 1){//这里改成随机选结果不变，说明你的vemac就没有work啊
    %%%%%:   80-block  0
branch  0 never executed
branch  1 never executed
    #####:   81:                aCar->ve_count_srp = 3;
    #####:   82:                printf("continue to occupie this slot.\n");
    %%%%%:   82-block  0
call    0 never executed
    #####:   83:            }else if(aCar->ve_check_flag == 0 && aCar->ve_count_srp > 0){
    %%%%%:   83-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   83-block  1
branch  2 never executed
branch  3 never executed
    #####:   84:                aCar->ve_count_srp--;
    %%%%%:   84-block  0
    #####:   85:            }else if(aCar->ve_check_flag == 0 && aCar->ve_count_srp == 0){
    %%%%%:   85-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:   85-block  1
branch  2 never executed
branch  3 never executed
    #####:   86:                aCar->slot_occupied = choose_slot(aCar, ROLE_VeMAC);
    %%%%%:   86-block  0
call    0 never executed
    #####:   87:                aCar->slot_condition = 1;
        -:   88:            }
        -:   89:        }
    #####:   90:        aItem = aItem->next;
    %%%%%:   90-block  0
        -:   91:    }
        -:   92:
        -:   93:    //step3: 用完了，重置OHN和THN为NULL
    #####:   94:    aItem =ALL_Vehicles-> head;
    #####:   95:    while(aItem != NULL){
    %%%%%:   95-block  0
    %%%%%:   95-block  1
branch  0 never executed
branch  1 never executed
    #####:   96:        aCar = (struct vehicle*)aItem->datap;
    #####:   97:        for(int i = 0; i< SlotPerFrame; i++){
    %%%%%:   97-block  0
    %%%%%:   97-block  1
branch  0 never executed
branch  1 never executed
    #####:   98:            aCar->OHN[i] = NULL;
    #####:   99:            aCar->THN[i] = NULL;
    %%%%%:   99-block  0
        -:  100:        }
    #####:  101:        aItem = aItem->next;
    %%%%%:  101-block  0
        -:  102:    }
    #####:  103:}
        -:  104:
