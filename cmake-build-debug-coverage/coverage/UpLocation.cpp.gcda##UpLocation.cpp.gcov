        -:    0:Source:E:/BubbleMAC_INFOCOM/UpLocation.cpp
        -:    0:Graph:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\UpLocation.cpp.gcno
        -:    0:Data:E:\BubbleMAC_INFOCOM\cmake-build-debug-coverage\CMakeFiles\BubbleMAC_INFOCOM.dir\UpLocation.cpp.gcda
        -:    0:Runs:1
        -:    1://
        -:    2:// Created by cyx02 on 2022/6/27.
        -:    3://
        -:    4:
        -:    5:#include "UpLocation.h"
        -:    6:#include "common.h"
        -:    7:#include <stddef.h>
        -:    8:#include "vehicle.h"
        -:    9:#include <cstdio>
        -:   10:#include <stdlib.h>
        -:   11:#include "parameters.h"
        -:   12:#include "string.h"
        -:   13:#include <string>
        -:   14:
function _Z15init_simulationP8Duallist called 2800 returned 100% blocks executed 100%
     2800:   15:int init_simulation(struct Duallist *ALL_Vehicles){
        -:   16:    struct Item *aItem;
        -:   17:    struct vehicle *aCar;
     2800:   18:    aItem = ALL_Vehicles->head;
    39597:   19:    while (aItem != NULL){
     2800:   19-block  0
    39597:   19-block  1
branch  0 taken 36797
branch  1 taken 2800 (fallthrough)
    36797:   20:        aCar = (struct vehicle*)aItem->datap;
        -:   21:
        -:   22:        //---需要初始化的内容---//
    36797:   23:        aCar->handled = 0;
        -:   24:        //---需要初始化的内容---//
        -:   25:
    36797:   26:        aItem = aItem->next;
    36797:   26-block  0
        -:   27:    }
     2800:   28:    return 0;
     2800:   28-block  0
        -:   29:}
        -:   30:
        -:   31:
        -:   32:
        -:   33:// Update location.
function _Z14updateLocationP8DuallistiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE called 2800 returned 100% blocks executed 95%
     2800:   34:void updateLocation(struct Duallist *ALL_Vehicles, int slot, string trace_path){
     2800:   35:    FILE *fin = NULL;
        -:   36:    int flag;
        -:   37:    int timestep;
        -:   38:    struct Item *aItem, *bItem;
        -:   39:    //struct neighbour_car* tNeigh, *nNeigh, *bNeigh;
        -:   40:    struct vehicle *aCar, *bCar;
     2800:   41:    int car_count = 0;
        -:   42:
     2800:   43:    trace_path += to_string(slot);
     2800:   43-block  0
call    0 returned 2800
branch  1 taken 2800 (fallthrough)
branch  2 taken 0 (throw)
     2800:   43-block  1
call    3 returned 2800
branch  4 taken 2800 (fallthrough)
branch  5 taken 0 (throw)
     2800:   43-block  2
call    6 returned 2800
    $$$$$:   43-block  3
call    7 never executed
    $$$$$:   43-block  4
     2800:   44:    trace_path += ".txt";
call    0 returned 2800
branch  1 taken 2800 (fallthrough)
branch  2 taken 0 (throw)
        -:   45:
        -:   46:    //printf("Loading vehilces...\n");
        -:   47:
        -:   48:    //sprintf(file_path, "C:\\Users\\cyx02\\Desktop\\SUMO\\highway\\transformerd\\carposition_%d.txt", slot);
        -:   49:    //fin = fopen(file_path, "r");
        -:   50:
        -:   51:    //printf("%s\n", trace_path.c_str());
     2800:   52:    fin = fopen(trace_path.c_str(), "r");
     2800:   52-block  0
call    0 returned 2800
call    1 returned 2800
branch  2 taken 2800 (fallthrough)
branch  3 taken 0 (throw)
        -:   53:
        -:   54:    //读取文件，添加车辆
    39597:   55:    while(fscanf(fin, "%d", &timestep)!=-1){
     2800:   55-block  0
    39597:   55-block  1
call    0 returned 39597
branch  1 taken 39597 (fallthrough)
branch  2 taken 0 (throw)
    39597:   55-block  2
branch  3 taken 36797
branch  4 taken 2800 (fallthrough)
        -:   56:        struct vehicle *new_car;
    36797:   57:        new_car=(struct vehicle*)malloc(sizeof(struct vehicle));
        -:   58:
    36797:   59:        new_car->handled = 2;//新车
        -:   60:        //load location information
    36797:   61:        fscanf(fin, "%s", new_car->id);
    36797:   61-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   62:        fscanf(fin, "%lf", &new_car->x);
    36797:   62-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   63:        fscanf(fin, "%lf", &new_car->y);
    36797:   63-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   64:        fscanf(fin, "%lf", &new_car->angle);
    36797:   64-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   65:        fscanf(fin, "%s", new_car->type);
    36797:   65-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   66:        fscanf(fin, "%lf", &new_car->speed);
    36797:   66-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   67:        fscanf(fin, "%lf", &new_car->pos);
    36797:   67-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   68:        fscanf(fin, "%s", new_car->lane);
    36797:   68-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   69:        fscanf(fin, "%lf", &new_car->slope);
    36797:   69-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   70:        fscanf(fin, "%lf", &new_car->flow);
    36797:   70-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:   71:        fscanf(fin, "%lf", &new_car->speed2);
    36797:   71-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
        -:   72:
    36797:   73:        new_car->a = 1;  //not updated
    36797:   74:        new_car->turn = 0;
        -:   75:        //init slot information
    36797:   76:        new_car->slot_condition = 1;
        -:   77:        //new_car->slot_occupied = 0;
    36797:   78:        new_car->slot_occupied = -1;
        -:   79:
        -:   80:
        -:   81:        // new_car->queue_Vehicles.clear();
        -:   82:        //init slot information for vemac
    36797:   83:        new_car->role_condition = 0;
    36797:   84:        new_car->slot_condition = 0;
    36797:   85:        new_car->slot_occupied = 0;
    36797:   86:        if(new_car->angle >= 0 && new_car->angle <180) new_car->ve_resource_pool = 1;
    36797:   86-block  0
branch  0 taken 36797 (fallthrough)
branch  1 taken 0
    36797:   86-block  1
branch  2 taken 17780 (fallthrough)
branch  3 taken 19017
    17780:   86-block  2
    19017:   87:        else new_car->ve_resource_pool = 0;
    19017:   87-block  0
        -:   88:
    36797:   89:        if(new_car->angle >= 0 && new_car->angle <180) new_car->resource_pool = 1;
    36797:   89-block  0
branch  0 taken 36797 (fallthrough)
branch  1 taken 0
    36797:   89-block  1
branch  2 taken 17780 (fallthrough)
branch  3 taken 19017
    17780:   89-block  2
    19017:   90:        else new_car->resource_pool = 0;
    19017:   90-block  0
        -:   91:
    36797:   92:        new_car->ve_count_srp = 3;
    36797:   93:        new_car->ve_check_flag = 1;
  7396197:   94:        for(int ii = 0; ii < SlotPerFrame; ii++){
    36797:   94-block  0
  7396197:   94-block  1
branch  0 taken 7359400
branch  1 taken 36797 (fallthrough)
  7359400:   95:            new_car->OHN[ii] = NULL;
  7359400:   96:            new_car->THN[ii] = NULL;
  7359400:   96-block  0
        -:   97:        }
        -:   98:
        -:   99:        // init commRange
        -:  100:        //new_car->commRadius = (new_car->speed/3.6)*(new_car->speed/3.6)/2/new_car->a;
        -:  101:
        -:  102:
    36797:  103:        duallist_init(&new_car->packets);
    36797:  103-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
    36797:  104:        duallist_init(&new_car->neighbours);
    36797:  104-block  0
call    0 returned 36797
branch  1 taken 36797 (fallthrough)
branch  2 taken 0 (throw)
        -:  105:        // duallist_init(&new_car->frontV);
        -:  106:        // duallist_init(&new_car->rearV);
        -:  107:
        -:  108:        //查找new_Car是否已经存在， 若存在，flag=true；若不存在，则flag = false;遍历一次ALL_Vehicles双链表，看是否已经存在（id是否相等），若相等则flag=true；若不相等，则flag=false
    36797:  109:        flag = false;
    36797:  110:        bItem = (struct Item*)ALL_Vehicles->head;
   527760:  111:        while(bItem != NULL){
    36797:  111-block  0
   527760:  111-block  1
branch  0 taken 526160
branch  1 taken 1600 (fallthrough)
   526160:  112:            bCar = (struct vehicle*)bItem->datap;
   526160:  113:            if (!strcmp(bCar->id, new_car->id)) {
   526160:  113-block  0
branch  0 taken 35197 (fallthrough)
branch  1 taken 490963
    35197:  114:                flag = true;
    35197:  115:                break;
    35197:  115-block  0
        -:  116:            }
   490963:  117:            bItem = bItem->next;
   490963:  117-block  0
        -:  118:        }
        -:  119:
        -:  120:        //若之前已存在，则更新其运动学信息
    36797:  121:        if(flag == true){
    36797:  121-block  0
branch  0 taken 35197 (fallthrough)
branch  1 taken 1600
    35197:  122:            bCar->x = new_car->x;
    35197:  123:            bCar->y = new_car->y;
    35197:  124:            bCar->angle = new_car->angle;
    35197:  125:            bCar->speed = new_car->speed;
    35197:  126:            bCar->pos = new_car->pos;
        -:  127:            // bCar->lane = new_car->lane;// there may be an error.
        -:  128:            // bCar->prev_lane = new_car->prev_lane;// error
    35197:  129:            if(strcmp(bCar->lane, new_car->lane) == 0){ // 判断是否进行变道，如果当前时刻与上一时刻的车道不同了，则turn变为1
    35197:  129-block  0
branch  0 taken 29490 (fallthrough)
branch  1 taken 5707
    29490:  130:                bCar->turn = 0;
    29490:  130-block  0
        -:  131:            }else{
     5707:  132:                bCar->turn = 1;
     5707:  132-block  0
        -:  133:            }
    35197:  134:            strcpy(bCar->prev_lane, new_car->lane);//记录下来是从哪个车道便过来的
    35197:  135:            strcpy(bCar->lane, new_car->lane);
        -:  136:
    35197:  137:            bCar->slope = new_car->slope;
    35197:  138:            bCar->flow = new_car->flow;
    35197:  139:            bCar->speed2 = new_car->speed2;
        -:  140:
        -:  141:            //update slot infor for vemac
        -:  142:            //bCar->ve_slot_condition = new_car->ve_slot_condition;
        -:  143:            //bCar->ve_slot_occupied = new_car->ve_slot_occupied;
    35197:  144:            bCar->ve_resource_pool = new_car->ve_resource_pool;
    35197:  145:            bCar->resource_pool = new_car->resource_pool;
        -:  146:            //bCar->ve_count_srp = new_car->ve_count_srp;
        -:  147:            //bCar->ve_check_flag = new_car->ve_check_flag;
        -:  148:
        -:  149:
    35197:  150:            bCar->handled = 1;//已有的车辆且处理
        -:  151:            // bCar->commRadius = new_car->commRadius;
    35197:  152:            bCar->resource_pool = new_car->resource_pool;
        -:  153:            // duallist_pick_item(ALL_Vehicles, bItem);//这样做也没错，只是没必要。。先不改了
        -:  154:            // duallist_add_to_tail(ALL_Vehicles, bCar);//添加更新后的节点
    35197:  155:            free(new_car);
    35197:  155-block  0
        -:  156:        }
        -:  157:
        -:  158:        //若之前不存在,则添加新车
    36797:  159:        if (flag == false){
    36797:  159-block  0
branch  0 taken 1600 (fallthrough)
branch  1 taken 35197
     1600:  160:            Car_Number++;
     1600:  161:            duallist_add_to_tail(ALL_Vehicles, new_car);
     1600:  161-block  0
call    0 returned 1600
branch  1 taken 1600 (fallthrough)
branch  2 taken 0 (throw)
        -:  162:        }
        -:  163:
        -:  164:    }
        -:  165:
     2800:  166:    fclose(fin);
     2800:  166-block  0
call    0 returned 2800
branch  1 taken 2800 (fallthrough)
branch  2 taken 0 (throw)
        -:  167:
        -:  168:    //处理消失的车(离开地图)，直接去掉即可。我的协议可以应对这种case，无非就是下个时刻听不到它了呗。没问题
     2800:  169:    aItem = ALL_Vehicles->head;
    41197:  170:    while(aItem != NULL){
     2800:  170-block  0
    41197:  170-block  1
branch  0 taken 38397
branch  1 taken 2800 (fallthrough)
    38397:  171:        aCar = (struct vehicle*)aItem->datap;
    38397:  172:        if(aCar->handled == 0){
    38397:  172-block  0
branch  0 taken 1600 (fallthrough)
branch  1 taken 36797
     1600:  173:            struct Item* deleteItem = aItem;
     1600:  174:            aItem = aItem->next;
     1600:  175:            duallist_pick_item(ALL_Vehicles, deleteItem);
     1600:  175-block  0
call    0 returned 1600
branch  1 taken 1600 (fallthrough)
branch  2 taken 0 (throw)
        -:  176:
        -:  177:        }else{
    36797:  178:            car_count++;
    36797:  179:            aItem = aItem->next;
    36797:  179-block  0
        -:  180:        }
        -:  181:    }
        -:  182:
        -:  183:    //printf("total car number in this slot: %d\n", car_count);
        -:  184:    //printf("Vehicles have been loaded!\n");
     5600:  185:    return;
     2800:  185-block  0
     2800:  185-block  1
        -:  186:}
        -:  187:
        -:  188://handle neighbors： 处理邻居，将所有车辆的所在的九宫格内的车挂载到其潜在的neighbors中,即每个车辆的neighbors就是当前九宫格内的邻居。暴力，两层循环。这里暴力是为了后面每次遍历的时候能少遍历一点
function _Z17handle_neighboursP8Duallist called 2800 returned 100% blocks executed 100%
     2800:  189:void handle_neighbours(struct Duallist *ALL_Vehicles){
        -:  190:    struct Cell *aCell, *nCell;
        -:  191:    struct Item *aItem, *nItem;
        -:  192:    struct vehicle* aCar, *nCar;
        -:  193:
     2800:  194:    aItem =ALL_Vehicles-> head;
    39597:  195:    while(aItem != NULL){
     2800:  195-block  0
    39597:  195-block  1
branch  0 taken 36797
branch  1 taken 2800 (fallthrough)
    36797:  196:        aCar = (struct vehicle*)aItem->datap;
    36797:  197:        duallist_destroy(&(aCar->neighbours), NULL);//先把之前的清空掉
    36797:  197-block  0
call    0 returned 36797
    36797:  198:        nItem = ALL_Vehicles-> head;
   987186:  199:        while(nItem != NULL){
   987186:  199-block  0
branch  0 taken 950389
branch  1 taken 36797 (fallthrough)
   950389:  200:            nCar = (struct vehicle*)nItem->datap;
        -:  201:            //id不相等且处于两千米以内，则将其加入到neighbors
   950389:  202:            if(strcmp(nCar->id, aCar->id)!=0 && distance_between_vehicle(aCar,nCar) < 2000){
   950389:  202-block  0
branch  0 taken 913592 (fallthrough)
branch  1 taken 36797
   913592:  202-block  1
call    2 returned 913592
branch  3 taken 913592 (fallthrough)
branch  4 taken 0
   913592:  202-block  2
    36797:  202-block  3
   950389:  202-block  4
branch  5 taken 913592 (fallthrough)
branch  6 taken 36797
   913592:  203:                duallist_add_to_tail(&(aCar->neighbours), nCar);//将id不同的车加入到neighbor list。
   913592:  203-block  0
call    0 returned 913592
        -:  204:            }
   950389:  205:            nItem = nItem->next;
   950389:  205-block  0
        -:  206:        }
    36797:  207:        aItem = aItem->next;
    36797:  207-block  0
        -:  208:    }
     2800:  209:}
        -:  210:
        -:  211:
